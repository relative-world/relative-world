import logging
import random
import time

from relative_world.actor import Actor
from relative_world.event import Event
from relative_world.location import Location
from relative_world.time import utcnow
from relative_world.world import RelativeWorld

# Configure logging
logging.basicConfig(level=logging.WARN, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class NewsEvent(Event):
    """
    Event that represents saying something aloud.

    Attributes:
        type (EventType): The type of the event, set to SAY_ALOUD.
        message (str): The message to be said aloud.
    """

    type: str = "NEWS"
    headline: str
    content: str


class UnbiasedNewspaper(Actor):
    """owned by an altruistic billionaire"""
    name: str = "Unbiased Newspaper"

    def update(self):
        """
        Updates the entity's state. Logs the time every fourth iteration, and a tick message on other iterations.

        Yields:
            Iterator[Event]: Events generated by the entity.
        """
        logging.debug(f"{self.name} ({self.id}) is updating.")
        headline_tag = random.choice(["Breaking", "Fake", "Real"])
        content = random.choice(["Everything is fine.", "Everything is not fine."])

        # you can emit events at any time
        # they will be queued until the end of the update
        self.emit_event(NewsEvent(headline=f"{headline_tag} News", content=content))

        # If you use emit_event, you must call the super method to flush the events.
        yield from super().update()


class Reddit(Actor):
    name: str = "Reddit"

    def update(self):
        """
        Updates the entity's state. Logs the time every fourth iteration, and a tick message on other iterations.

        Yields:
            Iterator[Event]: Events generated by the entity.
        """
        logging.debug(f"{self.name} ({self.id}) is updating.")
        reddit_headline = random.choice([
            "Look at this cat",
            "Birds aren't real",
            "I lost all my money in the stock market",
            "I (F30) just discovered my husband (M53) is a literal serial killer, AITA for calling the police?"]
        )
        reddit_content = random.choice([
            "I'm not sure what to do.",
            "I'm not sure what to do.",
            "I'm not sure what to do.",
            "I'm not sure what to do."
        ])

        # instead of using `emit_event`, you can also yield events directly
        yield from (
            (self, NewsEvent(headline=reddit_headline, content=reddit_content)),
        )


class TheMercury(Actor):
    name: str = "The Mercury"

    def act(self):
        """
        The simplest way to emit events is to yield them from the `act` method.
        These don't need to be BoundEvents because we assume anything come from the actor is from the actor.
        """
        logging.debug(f"{self.name} ({self.id}) is acting.")
        yield from (
            NewsEvent(headline="Anarchy in our time", content="Also it's slushy week."),
        )


class NewsReader(Actor):
    name: str

    def handle_event(self, entity, event):
        if isinstance(event, NewsEvent):
            logging.debug(f"{self.name} ({self.id}) is handling event: {event.headline} - {event.content}")
            print(f"{self.name} - {event.headline} - {event.content}")

def main():
    # First we must create the world
    world = RelativeWorld(name="World", simulation_start_time=utcnow())

    logging.debug("Created RelativeWorld")

    # Make some locations, a location is just an entity that doesn't default to propagating events.
    # it provides locality
    oregon = Location(name="Oregon")
    new_york = Location(name="New York", private=False)
    san_francisco = Location(name="San Francisco", private=False)
    logging.debug("Created locations: Oregon, New York, San Francisco")

    world.add_location(oregon)
    world.add_location(san_francisco)
    world.add_location(new_york)
    logging.debug("Added locations to the world")

    # now let's make some news sources to let us know what's going on in the world.
    unbiased_newspaper = UnbiasedNewspaper()
    reddit = Reddit()
    the_mercury = TheMercury()
    logging.debug("Created news sources: Unbiased Newspaper, Reddit, The Mercury")

    world.add_actor(unbiased_newspaper, location=new_york)
    world.add_actor(reddit, location=san_francisco)
    world.add_actor(the_mercury, location=oregon)
    logging.debug("Added The Mercury to Oregon")

    # Let's create an informed citizen to read the news
    informed_citizen = NewsReader(name="Informed Citizen")
    world.add_actor(informed_citizen, location=new_york)
    logging.debug("Added Informed Citizen to San Francisco")

    while True:
        logging.debug("Updating world")
        list(world.update())
        time.sleep(1)

if __name__ == "__main__":
    main()