import random
import time

from relative_world.actor import Actor
from relative_world.event import Event
from relative_world.location import Location
from relative_world.time import utcnow
from relative_world.world import RelativeWorld


class NewsEvent(Event):
    """
    Event that represents saying something aloud.

    Attributes:
        type (EventType): The type of the event, set to SAY_ALOUD.
        message (str): The message to be said aloud.
    """

    type: str = "NEWS"
    headline: str
    content: str


class UnbiasedNewspaper(Actor):
    """owned by an altruistic billionaire"""
    name: str = "Unbiased Newspaper"

    def update(self):
        """
        Updates the entity's state. Logs the time every fourth iteration, and a tick message on other iterations.

        Yields:
            Iterator[Event]: Events generated by the entity.
        """
        headline_tag = random.choice(["Breaking", "Fake", "Real"])
        content = random.choice(["Everything is fine.", "Everything is not fine."])

        # you can emit events at any time
        # they will be queued until the end of the update
        self.emit_event(NewsEvent(headline=f"{headline_tag} News", content=content))

        # If you use emit_event, you must call the super method to flush the events.
        yield from super().update()


class Reddit(Actor):
    name: str = "Reddit"

    def update(self):
        """
        Updates the entity's state. Logs the time every fourth iteration, and a tick message on other iterations.

        Yields:
            Iterator[Event]: Events generated by the entity.
        """
        reddit_headline = random.choice([
            "Look at this cat",
            "Birds aren't real",
            "I lost all my money in the stock market",
            "I (F30) just discovered my husband (M53) is a literal serial killer, AITA for calling the police?"]
        )
        reddit_content = random.choice([
            "I'm not sure what to do.",
            "I'm not sure what to do.",
            "I'm not sure what to do.",
            "I'm not sure what to do."
        ])

        # instead of using `emit_event`, you can also yield events directly
        yield from (
            (self, NewsEvent(headline=reddit_headline, content=reddit_content)),
        )


class TheMercury(Actor):
    name: str = "The Mercury"

    def act(self):
        """
        The simplest way to emit events is to yield them from the `act` method.
        These don't need to be BoundEvents because we assume anything come from the actor is from the actor.
        """
        yield from (
            NewsEvent(headline="Anarchy in our time", content="Also it's slushy week."),
        )



class NewsReader(Actor):
    name: str

    def handle_event(self, entity, event):
        if isinstance(event, NewsEvent):
            print(f"{self.name} - {event.headline} - {event.content}")


# First we must create the world
world = RelativeWorld(simulation_start_time=utcnow())

# Make some locations
oregon = Location(private=True)
san_francisco = Location(private=False)
new_york = Location(private=False)

world.add_location(oregon)
world.add_location(new_york)

# now let's make some news sources to let us know what's going on in the world.
unbiased_newspaper = UnbiasedNewspaper()
reddit = Reddit()
the_mercury = TheMercury()

world.add_actor(unbiased_newspaper)
world.add_actor(reddit)
world.add_actor(the_mercury)

# and place them in the world
unbiased_newspaper.location = new_york
reddit.location = san_francisco
the_mercury.location = oregon

# Let's create an informed citizen to read the news
informed_citizen = NewsReader(name="Informed Citizen")
world.add_actor(informed_citizen, location=san_francisco)
informed_citizen.location = san_francisco


while True:
    list(world.update())
    time.sleep(1)
